// src/entities/planet.ts (Refactored)

import { CONFIG } from '../config';
import { PLANET_TYPES, MineralRichness } from '../constants';
import { PRNG } from '../utils/prng';
import { RgbColour } from '../rendering/colour';
import { logger } from '../utils/logger';
import { generatePlanetCharacteristics, PlanetCharacteristics } from './planet/planet_characteristics_generator';
import { SurfaceGenerator, SurfaceData } from './planet/surface_generator';

// Re-export needed types if they aren't in a shared file
export type AtmosphereComposition = Record<string, number>;
export interface Atmosphere {
    density: string;
    pressure: number;
    composition: AtmosphereComposition;
}

/** Represents a planet, holding data generated by other modules. */
export class Planet {
    // Core Identification & Orbit
    public readonly name: string;
    public readonly type: string;
    public readonly orbitDistance: number;
    public orbitAngle: number; // Mutable
    public systemX: number; // Mutable
    public systemY: number; // Mutable

    // Physical Characteristics (Generated)
    public readonly diameter: number;
    public readonly gravity: number;
    public readonly surfaceTemp: number;
    public readonly atmosphere: Atmosphere;
    public readonly hydrosphere: string;
    public readonly lithosphere: string;

    // Resources & Gameplay (Generated + State)
    public readonly mineralRichness: MineralRichness;
    public readonly baseMinerals: number;
    public scanned: boolean = false;
    public primaryResource: string | null = null; // Determined by scan()

    // Generation & State
    public readonly systemPRNG: PRNG;
    public readonly mapSeed: string;

    // Surface Data (Lazy Loaded/Cached)
    private _surfaceData: SurfaceData | null = null; // Use private field for lazy loading
    private _surfaceGenerator: SurfaceGenerator | null = null; // Hold generator instance

    // Moons (Placeholder)
    public moons: Planet[] = [];

    constructor(
        name: string,
        type: string,
        orbitDistance: number,
        angle: number,
        systemPRNG: PRNG, // PRNG seeded for the parent system
        parentStarType: string
    ) {
        this.name = name;
        this.type = type;
        this.orbitDistance = orbitDistance;
        this.orbitAngle = angle;

        // Seed PRNG specifically for this planet
        this.systemPRNG = systemPRNG.seedNew("planet_" + name);
        logger.debug(`[Planet:${this.name}] Initialized PRNG with seed: ${this.systemPRNG.getInitialSeed()}`);

        // --- Generate Core Characteristics ---
        const characteristics: PlanetCharacteristics = generatePlanetCharacteristics(
            this.type,
            this.orbitDistance,
            this.systemPRNG,
            parentStarType
        );
        this.diameter = characteristics.diameter;
        this.gravity = characteristics.gravity;
        this.atmosphere = characteristics.atmosphere;
        this.surfaceTemp = characteristics.surfaceTemp; // Temp now calculated after atmosphere
        this.hydrosphere = characteristics.hydrosphere;
        this.lithosphere = characteristics.lithosphere;
        this.mineralRichness = characteristics.mineralRichness;
        this.baseMinerals = characteristics.baseMinerals;

        // Initial position based on orbit
        this.systemX = Math.cos(this.orbitAngle) * this.orbitDistance;
        this.systemY = Math.sin(this.orbitAngle) * this.orbitDistance;

        // Map seed for surface generation
        this.mapSeed = this.systemPRNG.getInitialSeed() + "_map";

        logger.info(`[Planet:${this.name}] Constructed Planet. Type=${this.type}, Orbit=${this.orbitDistance.toFixed(0)}, Temp=${this.surfaceTemp}K, Minerals=${this.mineralRichness}`);

        // Do NOT generate surface data in constructor for lazy loading
        // this.ensureSurfaceReady();
    }

    // --- Getters for Lazy-Loaded Surface Data ---
    get heightmap(): number[][] | null {
        if (!this._surfaceData && this.type !== 'GasGiant' && this.type !== 'IceGiant') {
            this.ensureSurfaceReady(); // Generate if needed
        }
        return this._surfaceData?.heightmap ?? null;
    }

    get heightLevelColors(): string[] | null {
         if (!this._surfaceData && this.type !== 'GasGiant' && this.type !== 'IceGiant') {
            this.ensureSurfaceReady(); // Generate if needed
        }
        return this._surfaceData?.heightLevelColors ?? null;
    }

     get rgbPaletteCache(): RgbColour[] | null {
         if (!this._surfaceData) { // All types might need this eventually
            this.ensureSurfaceReady(); // Generate if needed
        }
        return this._surfaceData?.rgbPaletteCache ?? null;
     }

    /** Ensures surface data is generated and cached if needed. Throws on failure. */
    ensureSurfaceReady(): void {
        if (this._surfaceData) {
            logger.debug(`[Planet:${this.name}] Surface data already generated.`);
            return; // Already generated
        }

        logger.info(`[Planet:${this.name}] ensureSurfaceReady: Generating surface data...`);
        if (!this._surfaceGenerator) {
            // Pass necessary generated characteristics to the SurfaceGenerator
             this._surfaceGenerator = new SurfaceGenerator(this.type, this.mapSeed, this.systemPRNG, this.atmosphere);
        }

        try {
            this._surfaceData = this._surfaceGenerator.generateSurfaceData();
            if (
                (this.type !== 'GasGiant' && this.type !== 'IceGiant' && (!this._surfaceData.heightmap || !this._surfaceData.heightLevelColors)) ||
                ((this.type === 'GasGiant' || this.type === 'IceGiant') && !this._surfaceData.rgbPaletteCache)
            ) {
                 throw new Error("Surface generator returned incomplete data.");
            }
            logger.info(`[Planet:${this.name}] Surface data generated successfully.`);
        } catch (error) {
            logger.error(`[Planet:${this.name}] Surface data generation failed:`, error);
            this._surfaceData = null; // Ensure it's null on failure
            throw error; // Re-throw after logging
        }
    }

    /** Performs a scan, determining the primary resource. */
    scan(): void {
        if (this.scanned) {
            logger.info(`[Planet:${this.name}] Scan attempted, but already scanned.`);
            return;
        }
        logger.info(`[Planet:${this.name}] Scanning planet...`);
        this.scanned = true;

        if (this.mineralRichness !== MineralRichness.NONE) {
            const resourcePRNG = this.systemPRNG.seedNew('resource');
            let potentialResources: string[] = [];
            switch (this.type) {
                case 'Rock': case 'Lunar': potentialResources = ['Common Metals', 'Silicates', 'Rare Elements', 'Precious Metals']; break;
                case 'Molten': potentialResources = ['Heavy Metals', 'Exotic Isotopes', 'Silicates']; break;
                case 'Frozen': potentialResources = ['Water Ice', 'Methane Ice', 'Ammonia Ice', 'Frozen Gases']; break;
                case 'Oceanic': potentialResources = ['Water', 'Dissolved Minerals', 'Exotic Lifeforms?']; break;
                default: potentialResources = ['Unknown Raw Materials']; break;
            }

            if (potentialResources.length > 0) {
                this.primaryResource = resourcePRNG.choice(potentialResources)!;
            } else {
                this.primaryResource = 'Undetermined';
            }

            if (this.mineralRichness === MineralRichness.EXCEPTIONAL && resourcePRNG.random() < 0.5) {
                const rareResources = ['Exotic Matter', 'Artifact Shards', 'Precious Gems', 'Anti-Matter Traces'];
                const oldResource = this.primaryResource;
                this.primaryResource = resourcePRNG.choice(rareResources)!;
                logger.info(`[Planet:${this.name}] Exceptional richness yielded rare resource: ${this.primaryResource} (overwriting ${oldResource})`);
            }
        } else {
            this.primaryResource = 'None Detected';
        }
        logger.info(`[Planet:${this.name}] Scan complete. Resource: ${this.primaryResource}, Richness: ${this.mineralRichness}`);
    }

    /** Returns multi-line scan information for the planet. */
    getScanInfo(): string[] {
        // Uses the generated characteristics stored in the instance
        logger.debug(`[Planet:${this.name}] getScanInfo called (Scanned: ${this.scanned})`);
        let infoLines: string[] = [
             `--- SCAN REPORT: ${this.name} ---`,
             `Type: ${this.type} Planet`,
        ];

        if (this.type === 'GasGiant' || this.type === 'IceGiant') {
             const compositionString = Object.entries(this.atmosphere.composition)
                 .filter(([, p]) => p > 0).sort(([, a], [, b]) => b - a)
                 .map(([gas, percent]) => `${gas}: ${percent}%`).join(', ') || "Trace Gases";
            infoLines.push(`Diameter: ${this.diameter} km | Gravity: ${this.gravity.toFixed(2)} G (at 1 bar level)`);
            infoLines.push(`Effective Temp: ${this.surfaceTemp} K (cloud tops)`);
            infoLines.push(`Atmosphere: ${this.atmosphere.density} (${this.atmosphere.pressure.toFixed(2)} bar at cloud tops)`);
            infoLines.push(`Composition: ${compositionString}`);
            infoLines.push(`Hydrosphere: ${this.hydrosphere}`);
            infoLines.push(`Lithosphere: ${this.lithosphere}`);
            infoLines.push(`Mineral Scan: ${this.mineralRichness}`); // Always None
            infoLines.push(`Refueling: Possible via atmospheric scoop.`);
        } else {
            infoLines.push(`Diameter: ${this.diameter} km | Gravity: ${this.gravity.toFixed(2)} G`);
            infoLines.push(`Surface Temp (Avg): ${this.surfaceTemp} K`);
            infoLines.push(`Atmosphere: ${this.atmosphere.density} (${this.atmosphere.pressure.toFixed(2)} bar)`);

            let compStr = "None";
            const comp = this.atmosphere.composition;
            if (comp && Object.keys(comp).length > 0 && comp['None'] !== 100) {
                 compStr = Object.entries(comp)
                     .filter(([, percent]) => percent > 0).sort(([, a], [, b]) => b - a)
                     .map(([gas, percent]) => `${gas}: ${percent}%`).join(', ');
            }
            infoLines.push(`Composition: ${compStr}`);
            infoLines.push(`Hydrosphere: ${this.hydrosphere}`);
            infoLines.push(`Lithosphere: ${this.lithosphere}`);

            if (this.scanned) {
                 infoLines.push(`Mineral Scan: Richness ${this.mineralRichness}. Primary Resource: ${this.primaryResource || 'N/A'}.`);
            } else {
                 infoLines.push(`Mineral Scan: Requires planetary scan. Richness potential: ${this.mineralRichness}.`);
            }
        }
        return infoLines;
    }

} // End Planet class